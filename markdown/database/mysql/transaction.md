# innodb事务

| 隔离级别                 | 脏读Dirty Read | 不可重复读 NonRepeatable Read |  幻读 Phantom Read |
| -------                 | ------------- | --------------------------- | -------------------- |
| 未提交读 Read uncommitted| 可能           | 可能                         | 可能
| 已提交读 Read committed  | 不可能         | 可能  |                       可能
| 可重复读 Repeatable read | 不可能         | 不可能  |                   可能
| 可串行化 Serializable    | 不可能         | 不可能  |                   不可能

## 事务的四种隔离级别

在数据库操作中，为了有效保证并发读取数据的正确性，提出的事务隔离级别。我们的数据库锁，也是为了构建这些隔离级别存在的

- **未提交读(Read Uncommitted)**：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
- **提交读(Read Committed)**：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- **可重复读(Repeated Read)**：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- **串行读(Serializable)**：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

## MySQL中锁的种类

- 常见的表锁和行锁
- 新加入的Metadata Lock等等,

- 表锁是对一整张表加锁，虽然可分为读锁和写锁，但毕竟是锁住整张表，会导致并发能力下降，一般是做ddl处理时使用。
- 行锁则是锁住数据行，这种加锁方法比较复杂，但是由于只锁住有限的数据，对于其它数据不加限制，所以并发能力强。

## 脏读和幻读

### 脏读

又称无效数据读出。
一个事务读取另外一个事务还没有提交的数据叫脏读

### 幻读

当某个事务在读取某个范围的记录的时候，另外一个事务又在该范围插入了新的记录，
当前事务再次读取这个范围的记录，会产生幻行（Phantom Data）。
