# 分布式事务六种解决方案

## 分布式事务

- 分布式事务顾名思义就是要在分布式系统中实现事务，它其实是由多个本地事务组合而成。
- 对于分布式事务而言几乎满足不了 ACID，其实对于单机事务而言大部分情况下也没有满足 ACID，不然怎么会有四种隔离级别呢？所以更别说分布在不同数据库或者不同应用上的分布式事务了。

## 一、2PC

2PC（Two-phase commit protocol），中文叫二阶段提交。 二阶段提交是一种强一致性设计，2PC 引入一个事务协调者的角色来协调管理各参与者（也可称之为各本地资源）的提交和回滚，二阶段分别指的是准备（投票）和提交两个阶段。

![2PC](https://monaco-cdn.oss-cn-shanghai.aliyuncs.com/aaf764d2-2cd0-4918-a436-b69b158beee0.jpg)

具体流程:

1. 准备阶段协调者会给各参与者发送准备命令，你可以把准备命令理解成除了提交事务之外啥事都做完了。
1. 同步等待所有资源的响应之后就进入第二阶段即提交阶段（注意提交阶段不一定是提交事务，也可能是回滚事务）。
1. 假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功。

**第二阶段提交失败**:

1. 第一种是第二阶段执行的是回滚事务操作，那么答案是不断重试，直到所有参与者都回滚了，不然那些在第一阶段准备成功的参与者会一直阻塞着。
1. 第二种是第二阶段执行的是提交事务操作，那么答案也是不断重试，因为有可能一些参与者的事务已经提交成功了，这个时候只有一条路，就是头铁往前冲，不断的重试，直到提交成功，到最后真的不行只能人工介入处理。

**弊端**：

1. 2PC 是一种尽量保证强一致性的分布式事务，因此它是同步阻塞的，而同步阻塞就导致长久的资源锁定问题，总体而言效率低，并且存在单点故障问题，在极端条件下存在数据不一致的风险。
1. 2PC 适用于数据库层面的分布式事务场景，而我们业务需求有时候不仅仅关乎数据库，也有可能是上传一张图片或者发送一条短信。

## 二、3PC

3PC 的出现是为了解决 2PC 的一些问题，相比于 2PC 它在参与者中也引入了超时机制，并且新增了一个阶段使得参与者可以利用这一个阶段统一各自的状态。
![3PC](https://monaco-cdn.oss-cn-shanghai.aliyuncs.com/0396caf8-e528-48db-bf7c-d747129a481d.jpg)

**3PC 三个阶段**：

1. 准备阶段 CanCommit
1. 预提交阶段 PreCommit
1. 提交阶段 DoCommit

### 2PC VS 3PC

- 3PC 相对于 2PC 做了一定的改进

  1. 引入了参与者超时机制
  1. 增加了预提交阶段使得故障恢复之后协调者的决策复杂度降低
  1. 整体的交互过程更长了，性能有所下降，并且还是会存在数据不一致问题。

- 2PC 和 3PC 都不能保证数据 100%一致，因此一般都需要有定时扫描补偿机制。

## 三、TCC (Try - Confirm - Cancel)

2PC 和 3PC 都是数据库层面的，而 TCC 是业务层面的分布式事务
![TCC](https://monaco-cdn.oss-cn-shanghai.aliyuncs.com/1823a3c0-a4d6-4f30-8ca9-20fceed02fb8.jpg)

1. Try 指的是预留，即资源的预留和锁定，注意是预留。
1. Confirm 指的是确认操作，这一步其实就是真正的执行了。
1. Cancel 指的是撤销操作，可以理解为把预留阶段的动作撤销了。

## 四、本地消息表

本地消息表其实就是利用了 各系统本地的事务来实现分布式事务。

本地消息表顾名思义就是会有一张存放本地消息的表，一般都是放在数据库中，然后在执行业务的时候 将业务的执行和将消息放入消息表中的操作放在同一个事务中，这样就能保证消息放入本地表中业务肯定是执行成功的。

然后再去调用下一个操作，如果下一个操作调用成功了好说，消息表的消息状态可以直接改成已成功。

如果调用失败也没事，会有 后台任务定时去读取本地消息表，筛选出还未成功的消息再调用对应的服务，服务更新成功了再变更消息的状态。

这时候有可能消息对应的操作不成功，因此也需要重试，重试就得保证对应服务的方法是幂等的，而且一般重试会有最大次数，超过最大次数可以记录下报警让人工处理。

可以看到本地消息表其实实现的是最终一致性，容忍了数据暂时不一致的情况。

## 五、消息事务

![消息事务](https://monaco-cdn.oss-cn-shanghai.aliyuncs.com/ce4bc3c9-7d7d-4f9a-a9c6-e047c4326e87.jpg)

RocketMQ 就很好的支持了消息事务，让我们来看一下如何通过消息实现事务。

1. 第一步先给 Broker 发送事务消息即半消息，半消息不是说一半消息，而是这个消息对消费者来说不可见，然后发送成功后发送方再执行本地事务。
1. 再根据本地事务的结果向 Broker 发送 Commit 或者 RollBack 命令。
1. 并且 RocketMQ 的发送方会提供一个反查事务状态接口，如果一段时间内半消息没有收到任何操作请求，那么 Broker 会通过反查接口得知发送方事务是否执行成功，然后执行 Commit 或者 RollBack 命令。
1. 如果是 Commit 那么订阅方就能收到这条消息，然后再做对应的操作，做完了之后再消费这条消息即可。
1. 如果是 RollBack 那么订阅方收不到这条消息，等于事务就没执行过。

通过 RocketMQ 还是比较容易实现的，RocketMQ 提供了事务消息的功能，我们只需要定义好事务反查接口即可。

## 六、最大努力通知

就本地消息表来说会有后台任务定时去查看未完成的消息，然后去调用对应的服务，当一个消息多次调用都失败的时候可以记录下然后引入人工，或者直接舍弃。这其实算是最大努力了。

适用于对时间不敏感的业务，例如短信通知。

## 总结

1. 2PC 和 3PC 是一种强一致性事务，不过还是有数据不一致，阻塞等风险，而且只能用在数据库层面。
1. TCC 是一种补偿性事务思想，适用的范围更广，在业务层面实现，因此对业务的侵入性较大，每一个操作都需要实现对应的三个方法。
1. 本地消息、事务消息和最大努力通知其实都是最终一致性事务，因此适用于一些对时间不敏感的业务。
